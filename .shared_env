#!/bin/sh
#
# Adam's shared environment startup file
#
# $Id$
#
# This should get run as part of setting up the environment
# of any sh-compatible shell, including non-interactive ones;
# hence it should be kept as fast and as portable as possible.
# Note that that means silly things like [ ! -e foo ] rather
# than ! [ -e foo ] ...

# Allow disabling of entire environment suite
[ -n "$INHERIT_ENV" ] && return 0

[ -n "$shared_env_loaded" ] && return 0

# {{{ Are we interactive?

case "$-" in
  *i*) shell_interactive=y ;;
    *) shell_interactive=  ;;
esac

# }}}

# {{{ Loading status

#[ "$shell" = -zsh ] && unsetopt function_argzero

# Default to 1, and treat empty as 0.  This ensures we have an integer.
: ${DEBUG_LOCAL_HOOKS=1}
: ${DEBUG_LOCAL_HOOKS:=0}

sh_load_status () {
  # Benchmarking: log wallclock time and elapsed since last call (no date fork)
  _sls_log=~/.log/sh_load_status.log
  # zsh requires loading zsh/datetime for EPOCHREALTIME; bash 5+ has it built-in
  [ -n "$BASH_VERSION" ] || zmodload zsh/datetime 2>/dev/null
  _sls_raw=$EPOCHREALTIME
  _sls_secs=${_sls_raw%.*}
  _sls_frac=${_sls_raw#*.}
  _sls_frac=${_sls_frac:0:3}
  _sls_now_ms="${_sls_secs}${_sls_frac}"
  if [ -n "$BASH_VERSION" ]; then
    printf -v _sls_ts "%(%H:%M:%S)T.%s" "$_sls_secs" "$_sls_frac"
  else
    strftime -s _sls_hms "%H:%M:%S" "$_sls_secs"
    _sls_ts="${_sls_hms}.${_sls_frac}"
  fi
  if [ -n "$_sls_last_ms" ]; then
    _sls_elapsed=$(( _sls_now_ms - _sls_last_ms ))
  else
    _sls_elapsed=0
  fi
  # Cache tty for the session (avoid repeated forks)
  if [ -z "$_sls_tty" ]; then
    if [ -n "$BASH_VERSION" ]; then
      _sls_tty=$(tty 2>/dev/null) || _sls_tty=unknown
    else
      # zsh: $TTY is a built-in variable
      _sls_tty=${TTY:-unknown}
    fi
    _sls_tty=${_sls_tty#/dev/}
  fi
  mkdir -p "${_sls_log%/*}"
  printf '%s  %s  (%4dms later)  %s\n' "$_sls_tty" "$_sls_ts" "$_sls_elapsed" "$*" >> "$_sls_log"
  _sls_last_ms=$_sls_now_ms

  # Find the name of the running shell
  _this_shell=${shell:-${0##*/}}

  # Find the filename of the running script
  if [ -n "$BASH_SOURCE" ]; then
    _this_script="${BASH_SOURCE[0]}"
    # Deduct 1 because array starts at 0, and another 1 because
    # we want to ignore this stack frame (inside sh_load_status)
    _this_script="${BASH_SOURCE[$(( ${#BASH_SOURCE[@]} - 2))]}"
    # Sheesh.  $ZSH_SOURCE[-2], anyone?
  else
    _this_script="$0"
    # Unfortunately in zsh there seems to be no way of determining
    # the currently running file if a function is being run, unless
    # function_argzero is unset :-/
    [ "$_this_script" = sh_load_status ] && _this_script=
    [ "$_this_script" = -zsh ] && _this_script=
  fi
  [ -n "$_this_script" ] && _this_script="[$_this_script]"

  # Leave status printed?
  
  if [ "$DEBUG_LOCAL_HOOKS" -ge 2 ]; then
    debug="\n"
  fi
  
  # \e[0K is clear to right
  if [ -n "$shell_interactive" ] && [ "$TERM" != 'dumb' ]; then
    _text="${_this_shell}${_this_script}: $*... "
    _text="${_text//\/home\//~}"
    echo -e -n "\r\e[0K$_text$debug"
  fi
}

# }}}

sh_load_status .shared_env

# {{{ ZDOTDIR, ZDOTDIRPATH, ZDOTUSER

# See .zshenv

zdotdir=${ZDOTDIR:-$HOME}
ZDOTDIR="$zdotdir"
ZDOT_RUN_HOOKS="$ZDOTDIR/.zsh/functions/run_hooks"
ZDOT_FIND_HOOKS="$ZDOTDIR/.zsh/functions/find_hooks"
export ZDOTDIR ZDOT_RUN_HOOKS ZDOT_FIND_HOOKS

# Define a search path to be used by run_hooks
if [ "$ZDOTDIR" = "$HOME" ]; then
  ZDOTDIRPATH=$ZDOTDIR
  ZDOTDIRREVPATH=$ZDOTDIR
else
  OTHER_USER=1
  export OTHER_USER
  ZDOTDIRPATH="$ZDOTDIR $HOME"
  ZDOTDIRREVPATH="$HOME $ZDOTDIR"
fi
export ZDOTDIRPATH ZDOTDIRREVPATH

[ -z "$ZDOTUSER" ] && [ -e ~/.zdotuser ] && ZDOTUSER=`cat ~/.zdotuser`
export ZDOTUSER

# }}}

# {{{ PATH

# Add directories to $PATH if they exist and aren't already present.
# Default is to prepend; use --append to append instead.
# Preserves the order of the given paths.
safe_add_to_path () {
    local append=
    if [ "$1" = "--append" ]; then
        append=1
        shift
    fi

    local new= dir=
    for dir in "$@"; do
        [ -d "$dir" ] || continue
        case ":$PATH:$new:" in
            *:"$dir":*) continue ;;
        esac
        if [ -z "$new" ]; then
            new="$dir"
        else
            new="$new:$dir"
        fi
    done

    if [ -n "$new" ]; then
        if [ -n "$append" ]; then
            PATH="$PATH:$new"
        else
            PATH="$new:$PATH"
        fi
    fi
}

# Don't trust system-wide PATH?  Remember what it was, for reference.
syspath=$HOME/.syspath.$HOST
if [ ! -e $syspath ]; then
    # Ignore failed write as home directory is sometimes locked down
    # cross-WAN.
    echo "$PATH" 2>/dev/null > "$syspath"
fi
#PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin

# ... or *do* trust system-wide PATH
PATH=/usr/local/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH

. $ZDOTDIR/.zsh/functions/enable_wordsplit
for dir in $ZDOTDIRREVPATH; do
  safe_add_to_path          \
      $dir/sbin             \
      $dir/bin              \
      $dir/.local/bin
done
restore_wordsplit

# }}}
# {{{ MANPATH

# In order to avoid forks here, this is done in .zshrc

# }}}

. $ZDOT_RUN_HOOKS .shared_env.d

if [ -n "$shell_interactive" ]; then
    . $ZDOTDIR/.shared_rc
fi

shared_env_loaded=y
